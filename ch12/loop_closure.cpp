#include "DBoW3/DBoW3.h"
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/features2d/features2d.hpp>
#include <iostream>
#include <vector>
#include <string>

using namespace cv;
using namespace std;

/***************************************************
 * 本节演示了如何根据前面训练的字典计算相似性评分
 * ************************************************/
int main( int argc, char** argv )
{
    // read the images and database  
    cout<<"reading database"<<endl;
    DBoW3::Vocabulary vocab("./vocabulary.yml.gz");
    // DBoW3::Vocabulary vocab("./vocab_larger.yml.gz");  // use large vocab if you want: 
    if ( vocab.empty() )
    {
        cerr<<"Vocabulary does not exist."<<endl;
        return 1;
    }
    cout<<"reading images... "<<endl;
    vector<Mat> images; 
    for ( int i=0; i<10; i++ )
    {
        string path = "../data/"+to_string(i+1)+".png";
        images.push_back( imread(path) );
    }
    
    // NOTE: in this case we are comparing images with a vocabulary generated by themselves, this may leed to overfitting.  
    // detect ORB features
    cout<<"detecting ORB features ... "<<endl;
    //Ptr< Feature2D > detector = ORB::create();
    Ptr<FeatureDetector> detector = FeatureDetector::create("ORB");
    Ptr<DescriptorExtractor> descriptor = DescriptorExtractor::create("ORB");
    vector<Mat> descriptors;
    for ( Mat& image:images )
    {
        vector<KeyPoint> keypoints; 
        Mat descriptor_;
        //detector->detectAndCompute( image, Mat(), keypoints, descriptor );
	    detector->detect ( image,keypoints );
	    //-- 第二步:根据角点位置计算 BRIEF 描述子
	    descriptor->compute ( image, keypoints, descriptor_ );
        descriptors.push_back( descriptor_ );
    }
    
    // we can compare the images directly or we can compare one image to a database 
    // images :
    cout<<"comparing images with images "<<endl;
    for ( int i=0; i<images.size(); i++ )
    {
        DBoW3::BowVector v1;
        vocab.transform( descriptors[i], v1 );
		std::cout <<"v1size "<<v1.size()<<std::endl;

		//debug
		// 通过打印没张图像产生的BowVector可以看出，不同的图像，很大可能性
		//产生的BowVector的map元素个数并不相同。
		//BowVector的map中，第一个元素是字典中的word编号，第二是通多tf-idf计算的
		//该词在词典中的权重
		DBoW3::BowVector::const_iterator vit;
		std::vector<unsigned int>::const_iterator iit;
		unsigned int m = 0; 
		const size_t N = v1.size();
		for(vit = v1.begin(); vit != v1.end(); ++vit, ++m)
		{
		  std::cout  << vit->first << ",  " << vit->second  <<std::endl;
		  
		}
        //
        for ( int j=i; j<images.size(); j++ )
        {
        
            DBoW3::BowVector v2;
            vocab.transform( descriptors[j], v2 );
			
			std::cout <<"v2size "<<v2.size()<<std::endl;
            double score = vocab.score(v1, v2);
            cout<<"image "<<i<<" vs image "<<j<<" : "<<score<<endl;
        }
        cout<<endl;
    }
    
    // or with database 
    cout<<"comparing images with database "<<endl;
    DBoW3::Database db( vocab, false, 0);
    for ( int i=0; i<descriptors.size(); i++ )
        db.add(descriptors[i]);
    cout<<"database info: "<<db<<endl;
    for ( int i=0; i<descriptors.size(); i++ )
    {
        DBoW3::QueryResults ret;
        db.query( descriptors[i], ret, 4);      // max result=4
        cout<<"searching for image "<<i<<" returns "<<ret<<endl<<endl;
    }
    cout<<"done."<<endl;
}
